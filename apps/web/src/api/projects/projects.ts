/**
 * Generated by orval v7.13.0 ðŸº
 * Do not edit manually.
 * Laravel
 * Content Creation Platform API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuthenticationExceptionResponse,
  ProjectsCreate201,
  ProjectsCreateBody,
  ProjectsGet200,
  ProjectsList200,
  ProjectsListParams,
  ProjectsProcess202,
  ProjectsProcess409,
  ProjectsStatus200,
  ProjectsUpdate200,
  ProjectsUpdateBody,
  ProjectsUpdateStage200,
  ProjectsUpdateStageBody,
  ValidationExceptionResponse
} from '../generated.schemas';

import { customInstance } from '../../lib/client/orval-fetcher';




export const projectsCreate = (
    projectsCreateBody: ProjectsCreateBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ProjectsCreate201>(
      {url: `/api/projects`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: projectsCreateBody, signal
    },
      );
    }
  


export const getProjectsCreateMutationOptions = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsCreate>>, TError,{data: ProjectsCreateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof projectsCreate>>, TError,{data: ProjectsCreateBody}, TContext> => {

const mutationKey = ['projectsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsCreate>>, {data: ProjectsCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  projectsCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof projectsCreate>>>
    export type ProjectsCreateMutationBody = ProjectsCreateBody
    export type ProjectsCreateMutationError = AuthenticationExceptionResponse | ValidationExceptionResponse

    export const useProjectsCreate = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsCreate>>, TError,{data: ProjectsCreateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsCreate>>,
        TError,
        {data: ProjectsCreateBody},
        TContext
      > => {

      const mutationOptions = getProjectsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const projectsList = (
    params?: ProjectsListParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ProjectsList200>(
      {url: `/api/projects`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getProjectsListQueryKey = (params?: ProjectsListParams,) => {
    return [`/api/projects`, ...(params ? [params]: [])] as const;
    }

    
export const getProjectsListQueryOptions = <TData = Awaited<ReturnType<typeof projectsList>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(params?: ProjectsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProjectsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof projectsList>>> = ({ signal }) => projectsList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof projectsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectsListQueryResult = NonNullable<Awaited<ReturnType<typeof projectsList>>>
export type ProjectsListQueryError = AuthenticationExceptionResponse | ValidationExceptionResponse


export function useProjectsList<TData = Awaited<ReturnType<typeof projectsList>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params: undefined |  ProjectsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsList>>,
          TError,
          Awaited<ReturnType<typeof projectsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsList<TData = Awaited<ReturnType<typeof projectsList>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params?: ProjectsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsList>>,
          TError,
          Awaited<ReturnType<typeof projectsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsList<TData = Awaited<ReturnType<typeof projectsList>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params?: ProjectsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useProjectsList<TData = Awaited<ReturnType<typeof projectsList>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params?: ProjectsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProjectsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const projectsGet = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ProjectsGet200>(
      {url: `/api/projects/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getProjectsGetQueryKey = (id?: string,) => {
    return [`/api/projects/${id}`] as const;
    }

    
export const getProjectsGetQueryOptions = <TData = Awaited<ReturnType<typeof projectsGet>>, TError = AuthenticationExceptionResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProjectsGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof projectsGet>>> = ({ signal }) => projectsGet(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof projectsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectsGetQueryResult = NonNullable<Awaited<ReturnType<typeof projectsGet>>>
export type ProjectsGetQueryError = AuthenticationExceptionResponse


export function useProjectsGet<TData = Awaited<ReturnType<typeof projectsGet>>, TError = AuthenticationExceptionResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsGet>>,
          TError,
          Awaited<ReturnType<typeof projectsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsGet<TData = Awaited<ReturnType<typeof projectsGet>>, TError = AuthenticationExceptionResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsGet>>,
          TError,
          Awaited<ReturnType<typeof projectsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsGet<TData = Awaited<ReturnType<typeof projectsGet>>, TError = AuthenticationExceptionResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useProjectsGet<TData = Awaited<ReturnType<typeof projectsGet>>, TError = AuthenticationExceptionResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProjectsGetQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const projectsUpdate = (
    id: string,
    projectsUpdateBody: ProjectsUpdateBody,
 ) => {
      
      
      return customInstance<ProjectsUpdate200>(
      {url: `/api/projects/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: projectsUpdateBody
    },
      );
    }
  


export const getProjectsUpdateMutationOptions = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsUpdate>>, TError,{id: string;data: ProjectsUpdateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof projectsUpdate>>, TError,{id: string;data: ProjectsUpdateBody}, TContext> => {

const mutationKey = ['projectsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsUpdate>>, {id: string;data: ProjectsUpdateBody}> = (props) => {
          const {id,data} = props ?? {};

          return  projectsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof projectsUpdate>>>
    export type ProjectsUpdateMutationBody = ProjectsUpdateBody
    export type ProjectsUpdateMutationError = AuthenticationExceptionResponse | ValidationExceptionResponse

    export const useProjectsUpdate = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsUpdate>>, TError,{id: string;data: ProjectsUpdateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsUpdate>>,
        TError,
        {id: string;data: ProjectsUpdateBody},
        TContext
      > => {

      const mutationOptions = getProjectsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const projectsDelete = (
    id: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/projects/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getProjectsDeleteMutationOptions = <TError = AuthenticationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof projectsDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['projectsDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  projectsDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof projectsDelete>>>
    
    export type ProjectsDeleteMutationError = AuthenticationExceptionResponse

    export const useProjectsDelete = <TError = AuthenticationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsDelete>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getProjectsDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const projectsStatus = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ProjectsStatus200>(
      {url: `/api/projects/${id}/status`, method: 'GET', signal
    },
      );
    }
  

export const getProjectsStatusQueryKey = (id?: string,) => {
    return [`/api/projects/${id}/status`] as const;
    }

    
export const getProjectsStatusQueryOptions = <TData = Awaited<ReturnType<typeof projectsStatus>>, TError = AuthenticationExceptionResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProjectsStatusQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof projectsStatus>>> = ({ signal }) => projectsStatus(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof projectsStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectsStatusQueryResult = NonNullable<Awaited<ReturnType<typeof projectsStatus>>>
export type ProjectsStatusQueryError = AuthenticationExceptionResponse


export function useProjectsStatus<TData = Awaited<ReturnType<typeof projectsStatus>>, TError = AuthenticationExceptionResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsStatus>>,
          TError,
          Awaited<ReturnType<typeof projectsStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsStatus<TData = Awaited<ReturnType<typeof projectsStatus>>, TError = AuthenticationExceptionResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectsStatus>>,
          TError,
          Awaited<ReturnType<typeof projectsStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProjectsStatus<TData = Awaited<ReturnType<typeof projectsStatus>>, TError = AuthenticationExceptionResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useProjectsStatus<TData = Awaited<ReturnType<typeof projectsStatus>>, TError = AuthenticationExceptionResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof projectsStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProjectsStatusQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const projectsUpdateStage = (
    id: string,
    projectsUpdateStageBody: ProjectsUpdateStageBody,
 ) => {
      
      
      return customInstance<ProjectsUpdateStage200>(
      {url: `/api/projects/${id}/stage`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: projectsUpdateStageBody
    },
      );
    }
  


export const getProjectsUpdateStageMutationOptions = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsUpdateStage>>, TError,{id: string;data: ProjectsUpdateStageBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof projectsUpdateStage>>, TError,{id: string;data: ProjectsUpdateStageBody}, TContext> => {

const mutationKey = ['projectsUpdateStage'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsUpdateStage>>, {id: string;data: ProjectsUpdateStageBody}> = (props) => {
          const {id,data} = props ?? {};

          return  projectsUpdateStage(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsUpdateStageMutationResult = NonNullable<Awaited<ReturnType<typeof projectsUpdateStage>>>
    export type ProjectsUpdateStageMutationBody = ProjectsUpdateStageBody
    export type ProjectsUpdateStageMutationError = AuthenticationExceptionResponse | ValidationExceptionResponse

    export const useProjectsUpdateStage = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsUpdateStage>>, TError,{id: string;data: ProjectsUpdateStageBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsUpdateStage>>,
        TError,
        {id: string;data: ProjectsUpdateStageBody},
        TContext
      > => {

      const mutationOptions = getProjectsUpdateStageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const projectsProcess = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ProjectsProcess202>(
      {url: `/api/projects/${id}/process`, method: 'POST', signal
    },
      );
    }
  


export const getProjectsProcessMutationOptions = <TError = AuthenticationExceptionResponse | ProjectsProcess409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsProcess>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof projectsProcess>>, TError,{id: string}, TContext> => {

const mutationKey = ['projectsProcess'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof projectsProcess>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  projectsProcess(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProjectsProcessMutationResult = NonNullable<Awaited<ReturnType<typeof projectsProcess>>>
    
    export type ProjectsProcessMutationError = AuthenticationExceptionResponse | ProjectsProcess409

    export const useProjectsProcess = <TError = AuthenticationExceptionResponse | ProjectsProcess409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof projectsProcess>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof projectsProcess>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getProjectsProcessMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    