/**
 * Generated by orval v7.13.0 ðŸº
 * Do not edit manually.
 * Laravel
 * Content Creation Platform API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuthenticationExceptionResponse,
  PostsAnalytics200,
  PostsAnalyticsParams,
  PostsAutoSchedule200,
  PostsAutoScheduleProject200,
  PostsAutoScheduleProjectBody,
  PostsBulkRegenerate200,
  PostsBulkRegenerateBody,
  PostsBulkSetStatus200,
  PostsBulkSetStatusBody,
  PostsFrameworks200,
  PostsGet200,
  PostsHookWorkbench200,
  PostsHookWorkbenchBody,
  PostsListByProject200,
  PostsListByProjectParams,
  PostsListScheduled200,
  PostsListScheduledParams,
  PostsPublishNow200,
  PostsSchedule200,
  PostsScheduleBody,
  PostsUnschedule200,
  PostsUpdate200,
  PostsUpdateBody,
  ValidationExceptionResponse
} from '../generated.schemas';

import { customInstance } from '../../lib/client/orval-fetcher';




export const postsFrameworks = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsFrameworks200>(
      {url: `/api/posts/hooks/frameworks`, method: 'GET', signal
    },
      );
    }
  

export const getPostsFrameworksQueryKey = () => {
    return [`/api/posts/hooks/frameworks`] as const;
    }

    
export const getPostsFrameworksQueryOptions = <TData = Awaited<ReturnType<typeof postsFrameworks>>, TError = AuthenticationExceptionResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsFrameworks>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsFrameworksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsFrameworks>>> = ({ signal }) => postsFrameworks(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsFrameworks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsFrameworksQueryResult = NonNullable<Awaited<ReturnType<typeof postsFrameworks>>>
export type PostsFrameworksQueryError = AuthenticationExceptionResponse


export function usePostsFrameworks<TData = Awaited<ReturnType<typeof postsFrameworks>>, TError = AuthenticationExceptionResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsFrameworks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsFrameworks>>,
          TError,
          Awaited<ReturnType<typeof postsFrameworks>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsFrameworks<TData = Awaited<ReturnType<typeof postsFrameworks>>, TError = AuthenticationExceptionResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsFrameworks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsFrameworks>>,
          TError,
          Awaited<ReturnType<typeof postsFrameworks>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsFrameworks<TData = Awaited<ReturnType<typeof postsFrameworks>>, TError = AuthenticationExceptionResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsFrameworks>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePostsFrameworks<TData = Awaited<ReturnType<typeof postsFrameworks>>, TError = AuthenticationExceptionResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsFrameworks>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsFrameworksQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postsListByProject = (
    id: string,
    params?: PostsListByProjectParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsListByProject200>(
      {url: `/api/posts/projects/${id}/posts`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getPostsListByProjectQueryKey = (id?: string,
    params?: PostsListByProjectParams,) => {
    return [`/api/posts/projects/${id}/posts`, ...(params ? [params]: [])] as const;
    }

    
export const getPostsListByProjectQueryOptions = <TData = Awaited<ReturnType<typeof postsListByProject>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(id: string,
    params?: PostsListByProjectParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsListByProject>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsListByProjectQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsListByProject>>> = ({ signal }) => postsListByProject(id,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsListByProject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsListByProjectQueryResult = NonNullable<Awaited<ReturnType<typeof postsListByProject>>>
export type PostsListByProjectQueryError = AuthenticationExceptionResponse | ValidationExceptionResponse


export function usePostsListByProject<TData = Awaited<ReturnType<typeof postsListByProject>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 id: string,
    params: undefined |  PostsListByProjectParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsListByProject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsListByProject>>,
          TError,
          Awaited<ReturnType<typeof postsListByProject>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsListByProject<TData = Awaited<ReturnType<typeof postsListByProject>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 id: string,
    params?: PostsListByProjectParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsListByProject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsListByProject>>,
          TError,
          Awaited<ReturnType<typeof postsListByProject>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsListByProject<TData = Awaited<ReturnType<typeof postsListByProject>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 id: string,
    params?: PostsListByProjectParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsListByProject>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePostsListByProject<TData = Awaited<ReturnType<typeof postsListByProject>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 id: string,
    params?: PostsListByProjectParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsListByProject>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsListByProjectQueryOptions(id,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postsListScheduled = (
    params?: PostsListScheduledParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsListScheduled200>(
      {url: `/api/posts/scheduled`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getPostsListScheduledQueryKey = (params?: PostsListScheduledParams,) => {
    return [`/api/posts/scheduled`, ...(params ? [params]: [])] as const;
    }

    
export const getPostsListScheduledQueryOptions = <TData = Awaited<ReturnType<typeof postsListScheduled>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(params?: PostsListScheduledParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsListScheduled>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsListScheduledQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsListScheduled>>> = ({ signal }) => postsListScheduled(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsListScheduled>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsListScheduledQueryResult = NonNullable<Awaited<ReturnType<typeof postsListScheduled>>>
export type PostsListScheduledQueryError = AuthenticationExceptionResponse | ValidationExceptionResponse


export function usePostsListScheduled<TData = Awaited<ReturnType<typeof postsListScheduled>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params: undefined |  PostsListScheduledParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsListScheduled>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsListScheduled>>,
          TError,
          Awaited<ReturnType<typeof postsListScheduled>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsListScheduled<TData = Awaited<ReturnType<typeof postsListScheduled>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params?: PostsListScheduledParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsListScheduled>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsListScheduled>>,
          TError,
          Awaited<ReturnType<typeof postsListScheduled>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsListScheduled<TData = Awaited<ReturnType<typeof postsListScheduled>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params?: PostsListScheduledParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsListScheduled>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePostsListScheduled<TData = Awaited<ReturnType<typeof postsListScheduled>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params?: PostsListScheduledParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsListScheduled>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsListScheduledQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postsAnalytics = (
    params?: PostsAnalyticsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsAnalytics200>(
      {url: `/api/posts/analytics`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getPostsAnalyticsQueryKey = (params?: PostsAnalyticsParams,) => {
    return [`/api/posts/analytics`, ...(params ? [params]: [])] as const;
    }

    
export const getPostsAnalyticsQueryOptions = <TData = Awaited<ReturnType<typeof postsAnalytics>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(params?: PostsAnalyticsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsAnalytics>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsAnalyticsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsAnalytics>>> = ({ signal }) => postsAnalytics(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsAnalytics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsAnalyticsQueryResult = NonNullable<Awaited<ReturnType<typeof postsAnalytics>>>
export type PostsAnalyticsQueryError = AuthenticationExceptionResponse | ValidationExceptionResponse


export function usePostsAnalytics<TData = Awaited<ReturnType<typeof postsAnalytics>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params: undefined |  PostsAnalyticsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsAnalytics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsAnalytics>>,
          TError,
          Awaited<ReturnType<typeof postsAnalytics>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsAnalytics<TData = Awaited<ReturnType<typeof postsAnalytics>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params?: PostsAnalyticsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsAnalytics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsAnalytics>>,
          TError,
          Awaited<ReturnType<typeof postsAnalytics>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsAnalytics<TData = Awaited<ReturnType<typeof postsAnalytics>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params?: PostsAnalyticsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsAnalytics>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePostsAnalytics<TData = Awaited<ReturnType<typeof postsAnalytics>>, TError = AuthenticationExceptionResponse | ValidationExceptionResponse>(
 params?: PostsAnalyticsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsAnalytics>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsAnalyticsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postsGet = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsGet200>(
      {url: `/api/posts/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getPostsGetQueryKey = (id?: string,) => {
    return [`/api/posts/${id}`] as const;
    }

    
export const getPostsGetQueryOptions = <TData = Awaited<ReturnType<typeof postsGet>>, TError = AuthenticationExceptionResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsGet>>> = ({ signal }) => postsGet(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsGetQueryResult = NonNullable<Awaited<ReturnType<typeof postsGet>>>
export type PostsGetQueryError = AuthenticationExceptionResponse


export function usePostsGet<TData = Awaited<ReturnType<typeof postsGet>>, TError = AuthenticationExceptionResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsGet>>,
          TError,
          Awaited<ReturnType<typeof postsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsGet<TData = Awaited<ReturnType<typeof postsGet>>, TError = AuthenticationExceptionResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsGet>>,
          TError,
          Awaited<ReturnType<typeof postsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsGet<TData = Awaited<ReturnType<typeof postsGet>>, TError = AuthenticationExceptionResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePostsGet<TData = Awaited<ReturnType<typeof postsGet>>, TError = AuthenticationExceptionResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsGetQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postsUpdate = (
    id: string,
    postsUpdateBody: PostsUpdateBody,
 ) => {
      
      
      return customInstance<PostsUpdate200>(
      {url: `/api/posts/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: postsUpdateBody
    },
      );
    }
  


export const getPostsUpdateMutationOptions = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsUpdate>>, TError,{id: string;data: PostsUpdateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postsUpdate>>, TError,{id: string;data: PostsUpdateBody}, TContext> => {

const mutationKey = ['postsUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsUpdate>>, {id: string;data: PostsUpdateBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postsUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof postsUpdate>>>
    export type PostsUpdateMutationBody = PostsUpdateBody
    export type PostsUpdateMutationError = AuthenticationExceptionResponse | ValidationExceptionResponse

    export const usePostsUpdate = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsUpdate>>, TError,{id: string;data: PostsUpdateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsUpdate>>,
        TError,
        {id: string;data: PostsUpdateBody},
        TContext
      > => {

      const mutationOptions = getPostsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const postsPublishNow = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsPublishNow200>(
      {url: `/api/posts/${id}/publish`, method: 'POST', signal
    },
      );
    }
  


export const getPostsPublishNowMutationOptions = <TError = AuthenticationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsPublishNow>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postsPublishNow>>, TError,{id: string}, TContext> => {

const mutationKey = ['postsPublishNow'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsPublishNow>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  postsPublishNow(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsPublishNowMutationResult = NonNullable<Awaited<ReturnType<typeof postsPublishNow>>>
    
    export type PostsPublishNowMutationError = AuthenticationExceptionResponse

    export const usePostsPublishNow = <TError = AuthenticationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsPublishNow>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsPublishNow>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPostsPublishNowMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const postsSchedule = (
    id: string,
    postsScheduleBody: PostsScheduleBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsSchedule200>(
      {url: `/api/posts/${id}/schedule`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postsScheduleBody, signal
    },
      );
    }
  


export const getPostsScheduleMutationOptions = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsSchedule>>, TError,{id: string;data: PostsScheduleBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postsSchedule>>, TError,{id: string;data: PostsScheduleBody}, TContext> => {

const mutationKey = ['postsSchedule'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsSchedule>>, {id: string;data: PostsScheduleBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postsSchedule(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsScheduleMutationResult = NonNullable<Awaited<ReturnType<typeof postsSchedule>>>
    export type PostsScheduleMutationBody = PostsScheduleBody
    export type PostsScheduleMutationError = AuthenticationExceptionResponse | ValidationExceptionResponse

    export const usePostsSchedule = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsSchedule>>, TError,{id: string;data: PostsScheduleBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsSchedule>>,
        TError,
        {id: string;data: PostsScheduleBody},
        TContext
      > => {

      const mutationOptions = getPostsScheduleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const postsUnschedule = (
    id: string,
 ) => {
      
      
      return customInstance<PostsUnschedule200>(
      {url: `/api/posts/${id}/schedule`, method: 'DELETE'
    },
      );
    }
  


export const getPostsUnscheduleMutationOptions = <TError = AuthenticationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsUnschedule>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postsUnschedule>>, TError,{id: string}, TContext> => {

const mutationKey = ['postsUnschedule'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsUnschedule>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  postsUnschedule(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsUnscheduleMutationResult = NonNullable<Awaited<ReturnType<typeof postsUnschedule>>>
    
    export type PostsUnscheduleMutationError = AuthenticationExceptionResponse

    export const usePostsUnschedule = <TError = AuthenticationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsUnschedule>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsUnschedule>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPostsUnscheduleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const postsAutoSchedule = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsAutoSchedule200>(
      {url: `/api/posts/${id}/auto-schedule`, method: 'POST', signal
    },
      );
    }
  


export const getPostsAutoScheduleMutationOptions = <TError = AuthenticationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsAutoSchedule>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postsAutoSchedule>>, TError,{id: string}, TContext> => {

const mutationKey = ['postsAutoSchedule'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsAutoSchedule>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  postsAutoSchedule(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsAutoScheduleMutationResult = NonNullable<Awaited<ReturnType<typeof postsAutoSchedule>>>
    
    export type PostsAutoScheduleMutationError = AuthenticationExceptionResponse

    export const usePostsAutoSchedule = <TError = AuthenticationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsAutoSchedule>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsAutoSchedule>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPostsAutoScheduleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const postsAutoScheduleProject = (
    projectId: string,
    postsAutoScheduleProjectBody: PostsAutoScheduleProjectBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsAutoScheduleProject200>(
      {url: `/api/posts/projects/${projectId}/posts/auto-schedule`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postsAutoScheduleProjectBody, signal
    },
      );
    }
  


export const getPostsAutoScheduleProjectMutationOptions = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsAutoScheduleProject>>, TError,{projectId: string;data: PostsAutoScheduleProjectBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postsAutoScheduleProject>>, TError,{projectId: string;data: PostsAutoScheduleProjectBody}, TContext> => {

const mutationKey = ['postsAutoScheduleProject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsAutoScheduleProject>>, {projectId: string;data: PostsAutoScheduleProjectBody}> = (props) => {
          const {projectId,data} = props ?? {};

          return  postsAutoScheduleProject(projectId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsAutoScheduleProjectMutationResult = NonNullable<Awaited<ReturnType<typeof postsAutoScheduleProject>>>
    export type PostsAutoScheduleProjectMutationBody = PostsAutoScheduleProjectBody
    export type PostsAutoScheduleProjectMutationError = AuthenticationExceptionResponse | ValidationExceptionResponse

    export const usePostsAutoScheduleProject = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsAutoScheduleProject>>, TError,{projectId: string;data: PostsAutoScheduleProjectBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsAutoScheduleProject>>,
        TError,
        {projectId: string;data: PostsAutoScheduleProjectBody},
        TContext
      > => {

      const mutationOptions = getPostsAutoScheduleProjectMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const postsBulkSetStatus = (
    postsBulkSetStatusBody: PostsBulkSetStatusBody,
 ) => {
      
      
      return customInstance<PostsBulkSetStatus200>(
      {url: `/api/posts/bulk`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: postsBulkSetStatusBody
    },
      );
    }
  


export const getPostsBulkSetStatusMutationOptions = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsBulkSetStatus>>, TError,{data: PostsBulkSetStatusBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postsBulkSetStatus>>, TError,{data: PostsBulkSetStatusBody}, TContext> => {

const mutationKey = ['postsBulkSetStatus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsBulkSetStatus>>, {data: PostsBulkSetStatusBody}> = (props) => {
          const {data} = props ?? {};

          return  postsBulkSetStatus(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsBulkSetStatusMutationResult = NonNullable<Awaited<ReturnType<typeof postsBulkSetStatus>>>
    export type PostsBulkSetStatusMutationBody = PostsBulkSetStatusBody
    export type PostsBulkSetStatusMutationError = AuthenticationExceptionResponse | ValidationExceptionResponse

    export const usePostsBulkSetStatus = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsBulkSetStatus>>, TError,{data: PostsBulkSetStatusBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsBulkSetStatus>>,
        TError,
        {data: PostsBulkSetStatusBody},
        TContext
      > => {

      const mutationOptions = getPostsBulkSetStatusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const postsBulkRegenerate = (
    postsBulkRegenerateBody: PostsBulkRegenerateBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsBulkRegenerate200>(
      {url: `/api/posts/bulk/regenerate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postsBulkRegenerateBody, signal
    },
      );
    }
  


export const getPostsBulkRegenerateMutationOptions = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsBulkRegenerate>>, TError,{data: PostsBulkRegenerateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postsBulkRegenerate>>, TError,{data: PostsBulkRegenerateBody}, TContext> => {

const mutationKey = ['postsBulkRegenerate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsBulkRegenerate>>, {data: PostsBulkRegenerateBody}> = (props) => {
          const {data} = props ?? {};

          return  postsBulkRegenerate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsBulkRegenerateMutationResult = NonNullable<Awaited<ReturnType<typeof postsBulkRegenerate>>>
    export type PostsBulkRegenerateMutationBody = PostsBulkRegenerateBody
    export type PostsBulkRegenerateMutationError = AuthenticationExceptionResponse | ValidationExceptionResponse

    export const usePostsBulkRegenerate = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsBulkRegenerate>>, TError,{data: PostsBulkRegenerateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsBulkRegenerate>>,
        TError,
        {data: PostsBulkRegenerateBody},
        TContext
      > => {

      const mutationOptions = getPostsBulkRegenerateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const postsHookWorkbench = (
    id: string,
    postsHookWorkbenchBody: PostsHookWorkbenchBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PostsHookWorkbench200>(
      {url: `/api/posts/${id}/hooks/workbench`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postsHookWorkbenchBody, signal
    },
      );
    }
  


export const getPostsHookWorkbenchMutationOptions = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsHookWorkbench>>, TError,{id: string;data: PostsHookWorkbenchBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postsHookWorkbench>>, TError,{id: string;data: PostsHookWorkbenchBody}, TContext> => {

const mutationKey = ['postsHookWorkbench'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsHookWorkbench>>, {id: string;data: PostsHookWorkbenchBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postsHookWorkbench(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsHookWorkbenchMutationResult = NonNullable<Awaited<ReturnType<typeof postsHookWorkbench>>>
    export type PostsHookWorkbenchMutationBody = PostsHookWorkbenchBody
    export type PostsHookWorkbenchMutationError = AuthenticationExceptionResponse | ValidationExceptionResponse

    export const usePostsHookWorkbench = <TError = AuthenticationExceptionResponse | ValidationExceptionResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsHookWorkbench>>, TError,{id: string;data: PostsHookWorkbenchBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsHookWorkbench>>,
        TError,
        {id: string;data: PostsHookWorkbenchBody},
        TContext
      > => {

      const mutationOptions = getPostsHookWorkbenchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    